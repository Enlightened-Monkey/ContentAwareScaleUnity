#pragma kernel CalculateEnergy
#pragma kernel RemoveVerticalSeams
#pragma kernel InsertVerticalSeams

SamplerState sampler_LinearClamp;

// Input/Output Textures and Buffers
Texture2D<float4> SourceTexture;
Texture2D<float4> InputTexture;
RWTexture2D<float> EnergyMap;
RWTexture2D<float4> OutputTexture;
StructuredBuffer<int> Seams;

// Dimensions & Batch Size
int Width;
int Height;
int NumSeams;

// --- KERNEL 1: Calculate Energy Map (Grayscale Version) ---
[numthreads(8, 8, 1)]
void CalculateEnergy(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= Width || id.y >= Height)
        return;

    if (id.x == 0 || id.x == Width - 1 || id.y == 0 || id.y == Height - 1)
    {
        EnergyMap[id.xy] = 1000.0f;
        return;
    }

    // Standard luminance weights for converting RGB to grayscale
    const float3 LUMA = float3(0.299, 0.587, 0.114);

    // Read neighbor colors, convert to linear space, and then to grayscale immediately
    float luma_cx_minus = dot(SourceTexture.SampleLevel(sampler_LinearClamp, (id.xy + float2(-1, 0)) / float2(Width, Height), 0).rgb, LUMA);
    float luma_cx_plus = dot(SourceTexture.SampleLevel(sampler_LinearClamp, (id.xy + float2(1, 0)) / float2(Width, Height), 0).rgb, LUMA);
    float luma_cy_minus = dot(SourceTexture.SampleLevel(sampler_LinearClamp, (id.xy + float2(0, -1)) / float2(Width, Height), 0).rgb, LUMA);
    float luma_cy_plus = dot(SourceTexture.SampleLevel(sampler_LinearClamp, (id.xy + float2(0, 1)) / float2(Width, Height), 0).rgb, LUMA);

    // Calculate the gradient (rate of change) on the grayscale values
    float gx = luma_cx_plus - luma_cx_minus;
    float gy = luma_cy_plus - luma_cy_minus;

    // The rest is the same, but with simple floats instead of vectors
    float deltaX_sq = gx * gx;
    float deltaY_sq = gy * gy;
    
    EnergyMap[id.xy] = sqrt(deltaX_sq + deltaY_sq);
}


// --- KERNEL 2: Remove Vertical Seams (Unchanged) ---
[numthreads(8, 8, 1)]
void RemoveVerticalSeams(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) Width - NumSeams || id.y >= (uint) Height)
        return;

    int seamsToLeft = 0;
    for (int i = 0; i < NumSeams; i++)
    {
        int seamX = Seams[i * Height + id.y];
        if (seamX <= id.x + seamsToLeft)
        {
            seamsToLeft++;
        }
    }
    
    uint2 sourceCoord = id.xy + uint2(seamsToLeft, 0);
    OutputTexture[id.xy] = InputTexture[sourceCoord];
}


// --- KERNEL 3: Insert Vertical Seams (Unchanged) ---
[numthreads(8, 8, 1)]
void InsertVerticalSeams(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) Width + NumSeams || id.y >= (uint) Height)
        return;

    int seamsToLeft = 0;
    bool isNewPixel = false;
    
    for (int i = 0; i < NumSeams; i++)
    {
        int seamX = Seams[i * Height + id.y];
        if (seamX < id.x - seamsToLeft)
        {
            seamsToLeft++;
        }
    }
    
    int sourceX = id.x - seamsToLeft;

    for (int i = 0; i < NumSeams; i++)
    {
        int seamX = Seams[i * Height + id.y];
        if (seamX == sourceX - 1)
        {
            isNewPixel = true;
            break;
        }
    }

    if (isNewPixel)
    {
        float4 leftColor = InputTexture[uint2(sourceX - 1, id.y)];
        float4 rightColor = (sourceX < Width) ? InputTexture[uint2(sourceX, id.y)] : leftColor;
        OutputTexture[id.xy] = lerp(leftColor, rightColor, 0.5f);
    }
    else
    {
        OutputTexture[id.xy] = InputTexture[uint2(sourceX, id.y)];
    }
}